# 04장. 데이터베이스 확장

## 4.1 저장 서비스의 이해

상태 저장 서비스는 강한 일관성을 위해 팍소스(Paxos)와 같은 메커니즘을 선택하거나 최종 일관성 메커니즘을 선택할 수 있다. 이는 복잡한 결정이며 수많은 사항을 트레이드오프 해야한다. 가능한 모든 서비스를 상태 비저장으로 유지하고 상태 저장 서비스에만 상태를 유지하는 이유다.

## 4.2 데이터베이스 사용 결정

서비스의 데이터 저장 방법을 결정할 떄 데이터베이스를 사용할 지, 아니면 파일, 블록, 객체 스토리지와 같은 옵션에 대해 논의할 수 있다.

## 4.3 복제

데이터베이스를 확장하는 방법은 복제, 분할, 샤딩이다. 복제는 복제본이라고 하는 데이터의 사본을 만들어 다른 노드에 저장하는 것이다.

분할과 샤딩은 모두 데이터 집합을 부분 집합으로 나누는 것이다. 샤딩은 부분 집합이 여러 노드에 분산돼 있음을 의미하지만 분할은 그렇지 않다.

- 내결함성: 각 노드는 노드 또는 네트워크 장애 시 다른 노드에 백업할 수 있다.
- 더 높은 스토리지 용량
- 더 높은 처리량
- 더 낮은 지연 시간

읽기(SELECT 연산)를 확장하려면 해당 데이터의 복제본 수를 늘리면 된다.

### 4.3.1 복제본 분산

샤딩의 주요 장점은 다음과 같다.

- 스토리지 확장
- 메모리 확장
- 처리 확장
- 지역성

### 4.3.2 단일 리더 복제

단일 리더 복제에서는 모든 쓰기 작업이 리더라고 하는 단일 노드에서 발생한다. 단일 리더 복제는 쓰기가 아닌 읽기 확장에 관한 것이다. 

SQL 서비스는 ACID 일관성을 잃는다. 이는 높은 트래픽의 서비스를 제공하기 위해 SQL 데이터베이스를 수평 확장하기로 선택할 때 고려해야할 관련 사항이다. 

모든 쓰기는 주 리더 노드에서 발생하고 보조 리더를 포함한 팔로워에게 복제된다. 주 리더가 실패하면 장애 조치 프로세스가 보조 리더를 주 리더로 승격시킨다. 실패한 리더가 복구되면 보조 리더가 된다.

단일 노드는 팔로워와 공유할 수 있는 처리량에 제한이 있으므로 팔로워의 최대 수를 제한하며 이는 다시 읽기 확장성을 제한한다. 읽기를 더 확장하려면 다중 수준 복제를 사용할 수 있다. 각 노드는 처리할 수 있는 수의 팔로워에게 복제하며 이는 일관성이 더 지연된다는 트레이드 오프가 있다. (MySQL binlog 기반 복제는 단일 리더 복제의 예다)

**단일 리더 복제를 확장하기 위한 좋은 방법: 애플리케이션 계층의 쿼리 로직**

데이터베이스 크기를 줄일 수 없지만 SQL을 계속 사용하고 싶다면 데이터를 여러 SQL 데이터베이스로 나눌 수 있다. 이는 우리 서비스가 둘 이상의 SQL 데이터베이스에 연결되게끔 구성해야하며 적절한 데이터베이스에서 쿼리하게 애플리케이션의 SQL쿼리르 다시 작성해야함을 의미한다.

단일 테이블을 두 개 이상의 데이터베이스로 분할해야 한다면 애플리케이션은 여러 데이터베이스를 쿼리하고 결과를 결합해야 한다. 또한 애플리케이션은 특정 데이터를 포함하는 데이터베이스의 정보를 저장해야 한다. 이는 본질적으로 다중 리더 복제다.

### 4.3.3 다중 리더 복제

다중 리더와 리더 없는 복제는 쓰기 작업과 데이터베이스 저장 용량을 확장하기 위한 기술이다. 다중 리더 복제에서는 여러 노드가 리더로 지정되며 모든 리더에서 쓰기를 수행할 수 있다. 각 리더는 자신의 쓰기 내용을 다른 모든 노드에게 복제해야 한다.

**일관성 문제와 접근 방식**

이러한 복제는 순서가 중요한 작업에서 일관성 문제와 경쟁 조건 문제를 야기한다. 다른 노드에서 동일한 시계를 사용하려고 해도 각 노드가 시계 신호를 다른 시간에 수신하므로 작동하지 않는다. 이를 클록 스큐(Clock skew)라고 한다.

여기에서 시스템 설계 면접에서 흔히 접하는 일관성과 관련된 복제 문제와 시나리오를 다룬다. 

일관성은 다음과 같은 정의를 가진다.

- 여러 복제본에 대한 동일한 쿼리는 복제본이 다른 물리적 서버에 있더라도 동일한 결과를 반환해야 함
- 동일한 행에 영향을 미치는 다른 물리적 서버의 데이터 조작 언어(DML) 쿼리(INSERT, UPDATE, DELETE)는 전송된 순서대로 실행되어야 함

### 4.3.4 리더 없는 복제

리더 없는 복제에서는 읽기/쓰기가 어느 노드에서나 일어날 수 있다. 경쟁 조건은 정족수 개념을 도입하면 된다. N개의 노드가 있고 읽기/쓰기 모두 N/2 + 1개 노드의 정족수를 가진다면 일관성이 보장됨을 알 수 있다.

일관성을 원한다면 빠른 쓰기와 빠른 읽기 중 선택해야 한다. 빠른 쓰기가 필요하면 낮은 쓰기 정족수와 높은 읽기 정족수를 설정하고 빠른 읽기가 필요하면 그 반대로 한다. 그렇지 않으면 최종 일관성만 가능하며 업데이트와 삭제 작업은 일관성을 유지할 수 없다.

카산드라, 다이나모, 리악, 볼드모트(Voldemort)는 리더 없는 복제를 사용하는 데이터베이스의 예다. 카산드라에서 업데이트 작업은 경쟁 조건의 영향을 받지만 삭제 작업은 실제로 행을 삭제하는 대신 툼스톤을 사용해 구현한다.

### 4.3.5 HDFS 복제

### 4.3.6 추가 읽을 거리

## 4.4 샤딩된 데이터베이스로 저장 용량 확장하기

데이터베이스 크기가 단일 호스트의 용량을 초과해 증가하면 오래된 행을 삭제해야 한다. 이 오래된 데이터를 보존해야 한다면 HDFS, 카산드라와 같은 샤딩된 스토리지에 저장해야 한다.

### 4.4.1 샤딩된 RDBMS

## 4.5 이벤트 집계하기

샘플링과 집계는 데이터베이스 쓰기 빈도를 줄이는 일반적인 기법이다. 쓰기를 줄이는 것 외에도 캐싱과 근사화 같은 기법으로 데이터베이스 읽기를 줄일 수 있다. 

집계는 스트리밍 파이프라인을 사용해 구현할 수 있다. 

### 4.5.1 단일 계층 집계

### 4.5.2 다중 계층 집계

### 4.5.3 분할

### 4.5.4 대규모 키 공간 처리하기

### 4.5.5 복제와 내결함성

호스트가 다운되면 집계된 모든 이벤트를 잃게 된다. 이 때 체크포인팅과 데드 레터 큐를 사용할 수 있다. 그러나 많은 처리를 반복해야 하며 리소스를 낭비하므로 각 노드를 레디스와 같은 공유 인메모리 데이터베이스에 요청을 보내는 여러 상태 비저장 노드 클러스터로 구성된 독립적인 서비스로 전환하는 것이 방법이 될 수 있다.

## 4.6 배치와 스트리밍 ETL

ETL(추출, 변환, 적재)은 하나 이상의 소스에서 데이터를 복사해 대상 시스템으로 옮기는 일반적인 절차다. 배치와 스트리밍의 관계는 폴링(Polling)과 인터럽트(Interrupt)의 관계와 유사하다. 배치 작업은 폴링처럼 처리할 새 이벤트가 있는지와 관계없이 항상 정의된 주기로 실행되는 반면 스트리밍 작업은 트리거 조건이 충족될 때 마다 실행되며 이는 보통 새 이벤트가 발행될 때다.

에어플로우와 루이지(Luigi)는 일반적인 배치 도구이며 카프카와 플링크는 일반적인 스트리밍 도구이다. ETL 파이프라인은 작업의 방향성 비순환 그래프(DAG)로 구성된다. DAG에서 노드는 작업에 해당하고 그 선행자는 의존성을 나타낸다. 작업은 ETL 파이프라인의 단일 실행을 의미한다.

### 4.6.1 간단한 배치 ETL 파이프라인

### 4.6.2 메시징 용어

**메시징 시스템**

**메시지 큐**

**발행자/구독자**

**메시지 브로커**

**이벤트 스트리밍**

**풀(pull)과 푸시(push)**

### 4.6.3 카프카와 RabbitMQ

### 4.6.4 람다 아키텍처

## 4.7 비정규화

면접에서 자주 언급되는 더 빠른 읽기 연산을 위한 접근 방식은 JOIN 쿼리를 피하기 위해 스키마를 비정규화해 저장 공간을 속도와 맞바꾸는 것이다.

## 4.8 캐싱

### 4.8.1 읽기 전략

**캐시 어사이드(지연 로드)**

캐시 어사이드(Cache-aside)는 캐시가 데이터베이스 '옆에' 위치함을 의미한다. 요청이 오면 먼저 캐시에서 데이터를 읽고 캐시 히트 시 데이터를 반환한다. 캐시 미스 시 데이터베이스에서 읽고 캐시에 데이터를 쓴다. 그래서 데이터 후속 요청은 캐시 히트가 된다. 따라서 데이터를 처음 읽을 때만 로드되며 지연 로드 방식이다.

캐시 어사이드는 읽기 위주의 부하 처리 방식에 가장 적합하다.

**읽기 통과**

읽기 통과(read-through)나 쓰기 통과(write-through), 또는 지연 쓰기(write-back) 캐싱에서 애플리케이션은 캐시에 요청을 보내고 필요하면 캐시가 데이터베이스에 요청을 보낼 수 있다.

읽기 통과에서 캐시 미스가 발생하면 캐시는 데이터베이스에 요청하고 데이터를 캐싱한 다음 반환한다. 읽기 통과는 읽기 위주의 부하에 가장 적합하다. 트레이드오프는 캐시 어사이드와 달리 읽기 통과 캐시는 여러 데이터베이스 요청을 단일 캐시 값으로 그룹화할 수 없다는 것이다.

### 4.8.2 쓰기 전략

**쓰기 통과 방식**

모든 쓰기 작업은 캐시를 거쳐 데이터베이스로 전달된다.

**지연 쓰기/후속 쓰기(Write-behind) 방식**

애플리케이션은 데이터를 캐시에 쓰지만 캐시는 즉시 데이터베이스에 쓰지 않고 주기적으로 갱신된 데이터를 데이터베이스에 플러시한다.

**쓰기 우회 방식**

쓰기 우회(write-around) 방식에서 애플리케이션은 데이터베이스에만 기록한다. 캐시 미스가 발생할 때 캐시를 갱신한다.

## 4.9 독립 서비스로서의 캐싱

## 4.10 캐시할 수 있는 다양한 종류의 데이터와 캐싱 방법 예시

## 4.11 캐시 무효화

### 4.11.1 브라우저 캐시 무효화

브라우저 캐시에서는 보통 각 파일에 max-age를 설정한다. 만료 전 파일이 새 파일로 교체되면 핑거프린팅(fingerprinting) 기법을 사용해 이러한 파일에 새로운 식별자(버전 번호, 파일 이름이나 쿼리 문자열 해시)를 부여한다. 핑거프린팅을 사용하면 immutable cache-control 옵션을 사용해 원본 서버에 대한 불필요한 요청을 방지할 수 있다.

### 4.11.2 캐싱 서비스의 캐시 무효화

클라이언트의 캐시에 직접 접근할 수 없으므로 max-age 설정이나 핑거프린팅 같은 기법으로 제한된다. 

## 4.12 캐시 워밍

캐시 워밍은 CDN이나 프론트엔드나 백엔드 서비스 같은 서비스에 적용되며 브라우저 캐시에는 적용되지 않는다.

## 4.13 추가 자료

## 요약

- 상태 저장 서비스는 비저장 서비스보다 복잡하며 오류 발생 가능성도 높다. 따라서 시스템 설계는 서비스를 상태 비저장으로 유지하고 공유 상태 저장 서비스를 사용하려고 한다.
- 각 저장 기술은 특정 범주에 속한다.
  - 데이터베이스
  - 문서
  - 그래프
  - 파일 스토리지
  - 블록 스토리지
  - 객체 스토리지
- 데이터베이스를 확장하기 위한 다양한 복제 기술이 있다. 단일 리더 복제, 다중 리더 복제, 리더 없는 복제, HDFS 복제
- 데이터베이스가 용량 한계에 도달하면 샤딩이 필요하다.
- 데이터베이스 쓰기는 비용이 많이 들고 확장이 어려우므로 가능한 한 최소화 해야한다.
- 비정규화는 읽기 지연을 최소화하고 SELECT 쿼리르 단순화하지만 일관성, 느린 쓰기, 더 많은 저장 공간, 느린 인덱스 등의 트레이드오프가 있다.
- 자주 사용하는 쿼리를 메모리에 캐싱하자
- 읽기 전략은 빠른 읽기를 위한 것이므로 오랫동안 저장된 캐시와 트레이드오프 관계에 있다.
- 캐시 어라운드 방식은 읽기 위주 부하에 가장 적합하지만 캐시된 데이터가 오래될 수 있고 캐시 미스는 캐시가 없을 때보다 느리다.
- 읽기 통과 캐시는 데이터베이스에 직접 요청을 보냄으로써 애플리케이션 로직 부담을 줄인다.
- 쓰기 통과 캐시는 절대 오래되지 않지만 속도가 느리다.
- 지연 쓰기 캐시는 주기적으로 갱신된 데이터를 데이터베이스에 플러시하므로 다른 캐시 설계와 달리 장애로 인한 데이터 손실을 방지하려면 높은 가용성이 필요하다.
- 쓰기 우회 캐시는 쓰기가 느리고 캐시가 오래될 가능성이 높으므로 캐시된 데이터 변경 가능성이 낮은 상황에 적합하다.
