# 05장. 분산 트랜잭션

## 5.1 이벤트 기반 아키텍처(EDA)

EDA는 비동기적으로 논블록킹 방식이므로 요청은 처리될 필요가 없으며 이는 상당한 시간이 걸리고 높은 지연을 초래할 수 있다. 대신 이벤트를 발행하기만 하면 된다. 

## 5.2 이벤트 소싱

이벤트 소싱은 추가 전용 로그에 이벤트로 데이터나 데이터 변경을 저장하는 패턴이다. 이벤트 소싱의 개념은 이벤트 로그가 신뢰할 수 있는 단일 데이터 출처이며 다른 모든 데이터베이스는 이벤트 로그에서 파생된 데이터 표현이라는 것이다.

모든 쓰기는 먼저 이벤트 로그에 이뤄져야 한다. 이 쓰기가 성공한 후 하나 이상의 이벤트 핸들러가 이 새로운 이벤트를 소비하고 다른 데이터베이스에 쓴다.

이벤트 소싱은 다양한 방식으로 구현할 수 있다. 게시자는 카프카 토픽과 같은 이벤트 스토리지나 추가 전용 로그에 이벤트를 발행하거나 관계형 데이터베이스에 행을 쓰거나, MongoDB나 Couchbase 같은 문서 데이터베이스에 문서를 쓰거나 심지어 낮은 지연 시간을 위해 레디스나 아차피 이그나이트(Apache Ignite) 같은 인메모리 데이터베이스에 쓸 수 있다.

## 5.3 변경 데이터 캡처

변경 데이터 캡처(Change Data Capture, CDC)는 데이터 변경 이벤트를 변경 로그 이벤트 스트림에 기록하고 이 이벤트 스트림을 API를 통해 제공하는 방식이다.

CDC는 이벤트 소싱보다 일관성이 높고 지연 시간이 낮다. 이벤트 소싱에서 소비자가 처리하기 전에 요청이 로그에 일정 시간 머무를 수 있는 것과 달리 CDC는 요청을 거의 실시간으로 처리한다.

트랜잭션 로그 테일링 패턴은 또 다른 시스템 설계 패턴으로 프로세스가 데이터베이스에 쓰거나 카프카에 생성해야할 때 발생할 수 있는 불일치를 방지하기 위한 것이다. 두 쓰기 중 하나가 실패하면 불일치가 발생할 수 있다.

CDC 플랫폼으로는 Debezium, Databus, DynamoDB Streams, Eventuate CDC Service등이 있다.

## 5.4 이벤트 소싱과 CDC 비교

일부 시스템 설계에서는 이벤트 소싱과 CDC를 함께 사용할 수 있다. 예를 들어 서비스 내에서는 이벤트 소싱을 사용해 데이터 변경을 이벤트로 기록하고 CDC를 사용해 이러한 이벤트를 다른 서비스로 전파할 수 있다.

**목적**
- 이벤트 소싱: 이벤트를 기준 데이터로 기록
- CDC: 소스 서비스에서 다운 스트림 서비스로 이벤트를 전파해 데이터 변경을 동기화

**기준 데이터**
- 이벤트 소싱: 로그나 로그에 발행된 이벤트가 기준
- CDC: 발행자 서비스의 데이터베이스, 발행된 이벤트는 기준 데이터가 아니다.

**세분성**
- 이벤트 소싱: 특정 작업이나 상태 변경을 나타내는 세분화된 이벤트
- CDC: 새로 생성, 업데이트, 삭제된 행이나 문서 같은 개별 데이터베이스 수준의 변경

## 5.5 트랜잭션 감독자

트랜잭션 감독자는 트랜잭션이 성공적으로 완료되거나 취소되게 보장해주는 프로세스로써 주기적인 배치 작업이나 서버리스 함수로 구현할 수 있다.

## 5.6 사가 패턴

### 5.6.1 코레오그래피 방식

코레오그래피 방식에서 사가패턴은 분산 트랜잭션을 시작하기 위해 하나의 카프카 토픽에서 생성하고 최종 로직을 수행하기 위해 다른 카프카 토픽에서 소비한다. 사가 패턴의 다른 서비스들은 카프카 토픽을 통해 서로 직접 통신한다.

코레오그래피 방식에서 주목할 사항은 다음과 같다.

- 서비스가 동일한 토픽에 생성하거나 구독하지 않는다.
- 두 개의 서비스가 동일한 토픽에 생성하지 않는다.
- 서비스는 여러 토픽을 구독할 수 있다. 작업을 수행하기 전 여러 토픽에서 이벤트를 받아야 한다면 특정 이벤트를 받았다는 것을 데이터베이스에 기록해야 한다. 이를 통해 모든 이벤트가 수신되었는지 확인할 수 있다.
- 토픽과 서비스 간의 관계는 1:N이거나 N:1일 수 있지만 N:M은 아니다.
- 순환이 있을 수 있다.

### 5.6.2 오케스트레이션 방식

### 5.6.3 비교

| 코레오그래피 방식         | ㅁㄴㅇㅇㄴㅁ방식           |
|-------------------|--------------------|
| 서비스 요청이 병렬로 이뤄진다. | 서비스 요청이 선형적으로 이뤄진다 |
|사가 패턴을 시작하는 서비스는 두 개의 카프카 토픽과 통신한다. 분산 트랜잭션을 시작하기 위한 토픽과 최종 로직을 수행하기 위한 토픽이다|카프카 토픽을 통해 각 서비스와 통신한다. 사가 패턴의 각 단계에서 오케스트레이터는 이 단계를 시작하기 위해 토픽에 메시지를 새엇ㅇ하고 단계의 결과를 받기 위해 다른 토픽에서 소비한다|
|사가 패턴을 시작하는 서비스는 첫 번째 토픽에 메시지를 생성하고 마지막 토픽에서 메시지를 소비하는 코드만 존재한다. 개발자는 사가 패턴과 관련된 모든 서비스의 코드를 읽어야 단계를 이해할 수 있다.|오케스트레이터의 코드를 읽으면 분산 트랜잭션의 서비스와 단계를 이해할 수 있다.|
|서비스는 여러 토픽을 구독해야할 수 있다. 이는 여러 서비스에서 특정한 다른 이벤트를 소비했을 때만 특정 이벤트를 생성할 수 있기 때문이다. 이는 이미 소비한 이벤트를 데이터베이스에 기록해야함을 의미한다.|오케스트레이터를 제외하고 각 서비스는 하나의 토픽만 구독한다. 서비스가 특정 이벤트를 생성하기전에 별도의 서비스에서 여러 이벤트를 소비할 필요가 없으므로 데이터베이스 쓰기 횟수를 줄일 수 있다.|
|덜 자원 집약적이고 통신량이 적으며 네트워크 트래픽이 적어 전반적으로 지연 시간이 낮다.|모든 단계가 오케스트레이터를 거쳐야 하므로 이벤트 수가 코레오그래피 패턴의 두배다. 네트워크 트래픽이 비교적 많아 지연 시간이 높다.|
|병렬 요청도 지연 시간을 낮춘다.|요청이 선형적이므로 지연 시간이 높다.|
|SPOF가 없다.|오케스트레이션 서비스가 SPOF이기 때문에 높은 가용성이 필요하다.|
|보상 트랜잭션은 사가 패턴과 관련된 다양한 서비스에 트리거 된다.|보상 트랜잭션은 오케스트레이터에 의해 트리거된다.|

## 5.7 다른 트랜잭션 유형

아래 합의 알고리즘은 일반적으로 분산 데이터베이스에서 많은 수의 노드 합의를 달성하는데 더 유용하다.

- 정족수 쓰기(쿼럼)
- 팍소스와 EPaxos
- Raft
- Zab(주키퍼 원자적 브로드캐스트 프로토콜) - 아파치 주키퍼에서 사용
