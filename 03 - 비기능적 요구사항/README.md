# 03장. 비기능적 요구사항

기능적 요구사항은 API 명세와 엔드포인트로 표현할 수 있다. 비기능적 요구사항은 시스템 입력과 출력 이외의 요구사항을 말한다.
- 확장성
- 가용성
- 성능/지연 시간/P99와 처리량
- 내결함성
- 보안
- 프라이버시
- 정확성: 시스템의 데이터가 완벽하게 정확할 필요는 없으며 비용이나 복잡성을 개선하기 위한 정확도 트레이드오프가 종종 관련 논의의 대상이 된다.
- 일관성: 모든 노드/서버의 데이터가 일치하는지 여부
- 비용
- 복잡성/유지보수성/디버깅 가능성과 테스트 가능성

비기능적 요구사항은 일반적으로 서로 트레이드오프 이므로 모든 시스템 설계면접에서 다양한 트레이드 오프를 위해 어떤 설계 결정을 내릴 수 있는지 논의해야 한다.

## 3.1 확장성

- 시스템에 들어오고 시스템에서 검색되는 데이터의 양은 얼마인가?
- 초당 읽기 쿼리 수는 얼마인가?
- 요청당 데이터양은 얼마인가?
- 초당 비디오 조회 수는 얼마인가?
- 갑작스러운 트래픽 스파이크의 크기는 어느정도인가?

## 3.1.1 상태 비저장 서비스와 상태 저장 서비스

상태 비저장 HTTP 백엔드와 수평 확장 가능한 데이터베이스 읽기 작업의 조합은 확장 가능한 시스템 설계를 설명하는 좋은 시작점이다.

공유 스토리지 쓰기는 확장하기가 가장 어렵다. (복제, 압축, 집계, 비정규화, 메타 데이터 서비스 등의 기법이 존재)

## 3.1.2 기본 로드 밸런서 개념

OSI 4계층과 7계층 로드 밸런서를 구별할 수 있어야 하며 특정 서비스에 어떤 것이 더 적합한지 논의할 수 있어야 한다. 4계층 로드 밸런서는 전송 계층(TCP)에서 작동한다. TCP 스트림의 처음 몇 패킷에서 추출한 주소 정보를 기반으로 라우팅 결정을 내리고 다른 패킷의 내용은 검사하지 않으므로 패킷을 전달만 할 수 있다.

7계층 로드 밸런서는 응용 계층(HTTP)에서 작동하므로 다음과 같은 기능이 있다.
- 로드 밸런싱/라우팅 결정
- 인증
- TLS 종료

**고정 세션**

고정 세션은 로드 밸런서가 특정 클라이언트의 요청을 로드 밸런서나 애플리케이션이 설정한 기간 동안 특정 호스트로 보내는 것을 말한다. 온라인 쇼핑몰 웹사이트는 사용자 장바구니의 고정 세션을 사용할 수 있다.

**세션 복제**

세션 복제에서는 호스트 쓰기가 같은 세션에 할당된 클러스터의 다른 여러 호스트에 복사되므로 해당 세션을 가진 어떤 호스트로도 읽기를 라우팅할 수 있으며 이는 가용성을 향상 시킨다.

**로드 밸런싱 vs 리버스 프록시**

로드 밸런싱은 확장성을 위한 것이고 리버스 프록시는 클라이언트-서버 통신을 관리하기 위한 기술이다.

## 3.2 가용성

불필요한 복잡성 없이 높은 가용성을 허용하기 위해 다른 비기능적 요구사항을 트레이드오프 할 수 있다.

시스템의 비기능적 요구사항을 논의할 때 먼저 높은 가용성이 필요한지 확정해야 한다. 높은 일관성과 낮은 지연 시간이 필요하다고 가정하면 안된다. CAP 이론을 통해 가용성을 높이기 위해 이를 트레이드오프할 수 있는지 논의한다. (ex. 이벤트 소싱/사가 패턴과 같은 비동기식 커뮤니케이션)

비동기 서비스는 높은 일관성과 낮은 지연 시간이 필요할 가능성이 낮다. 즉각적인 응답이 절대적으로 필요하면 동기식 프로토콜을 사용해야 한다. 물론 사용자가 요청한 데이터에 대해 즉각적인 응답이 필요하다고 가정하면 안된다.

캐싱도 고려할 수 있다.

## 3.3 내결함성

내결함성은 일부 구성 요소가 실패해도 시스템이 계속 작동할 수 있는 능력과 다운타임이 발생했을 때 영구적인 데이터 손실 등을 방지하는 능력이다.

### 3.3.1 복제와 중복

한가지 복제 기법은 구성 요소의 중복 인스턴스/복사본을 3개 이상 가지는 것이다. 그래서 최대 2개가 동시에 다운돼도 가동 시간에 영향을 미치지 않게 하는 것이다.

한 인스턴스는 리더로 지정되고 다른 두 구성 요소는 팔로워로 지정된다. 예를 들어 하둡과 분산 파일 시스템은 '복제 계수'라는 구성 가능한 속성이 있어 모든 블록의 복사본 수를 설정할 수 있다. 기본값은 3이다.

### 3.3.2 전방 오류 수정과 오류 수정 코드

### 3.3.3 서킷 브레이커

서킷 브레이커는 최근 간격 내에 실패한 요청 수를 계산하고 오류 임곗값을 초과하면 클라이언트는 다운스트림 서비스 호출을 중단한다. 일정 시간이 지난 후 클라이언트는 제한된 수의 요청을 시도하고 이 요청이 성공하면 실패가 해결됐다고 가정하고 다시 요청을 보내기 시작한다.

### 3.3.4 지수 백오프와 재시도

클라이언트는 지터(Jitter)라고 불리는 기법을 사용해 대기 시간을 무작위 음수나 양수 값으로 조정한다. 이는 여러 클라이언트가 정확히 같은 시간에 재시도를 제출해 다운스트림 서비스에 부하를 가하는 상황을 방지한다.

### 3.3.5 다른 서비스의 응답 캐싱

### 3.3.6 체크포인팅

체크포인팅은 카프카와 같은 메시지 브로커를 사용하는 ETL 파이프라인에 일반적으로 적용된다. 서버는 카프카 토픽에서 여러 이벤트를 가져와 처리한 다음 결과를 쓰고 체크포인트를 작성할 수 있다. 이 서버가 실패하면 대체 서버는 가장 최근의 체크포인트에서 재개할 수 있다.

카프카는 카프카 내 파티션 수준에서 오프셋 스토리지를 제공한다. 플링크(Flink)는 카프카 토픽에서 데이터를 소비하고 플링크의 분산 체크포인팅 메커니즘을 사용해 주기적으로 체크포인트를 만든다.

### 3.3.7 데드 레터 큐

서드파티 API 쓰기 요청이 실패하면 요청을 데드 레터 큐(Dead Letter Queue)에 넣고 나중에 다시 시도할 수 있다.

### 3.3.8 로깅과 주기적 감사

### 3.3.9 벌크헤드

벌크헤드(Bulkhead) 패턴은 내결함성 메커니즘으로 시스템을 격리된 풀로 나눠 한 풀의 결함이 전체 시스템에 영향을 미치지 않게 한다. 예를 들어 서비스의 다양한 엔드포인트는 각각 자체 스레드 풀을 가질 수 있으며 스레드 풀을 공유하지 않는다.

### 3.3.10 폴백 패턴

폴백 패턴은 문제를 탐지한 다음 대체 코드 경로를 실행하는 것으로 구성된다.

## 3.4 성능/지연 시간과 처리량

낮은 지연 시간 달성을 위해서 설계 결정은 다음과 같다. 사용자와 지리적으로 가까운 데이터 센터에 서비스를 배포하면 패킷 이동 거리를 줄일 수 있다. 사용자가 지리적으로 분산돼 있다면 사용자 클러스터와의 지리적 거리를 최소화하면 선택된 여러 데이터 센터에 서비스를 배포할 수 있다.

다른 기법으로는 CDN 사용, 캐싱, REST 대신 RPC로 데이터 크기 줄이기, 네티(Netty)와 같은 프레임워크로 자체 프로토콜을 설계하여 HTTP대신 TCP와 UDP를 사용, 그리고 배치와 스트리밍 기법 사용등이 있다.

조회 수를 몇 시간 후에 집계할 수 있다면 이는 배치나 스트리밍 접근 방식을 허용한다. 응답 시간이 짧다면 데이터는 이미 집계돼 있어야 하며 집계는 쓰기 중에 수행돼야하고 읽기 중에는 최소한의 집계만 하거나 전혀 하지 않아야 한다.

일관성은 ACID와 CAP 정리에서 다른 의미를 가진다. ACID 일관성은 외래 키와 고유성 같은 데이터 관계에 중점을 둔다. CAP에서의 일관성은 특정 시점에 모든 노드가 동일한 데이터를 가져야 함을 뜻한다.

결과적으로 일관된 데이터베이스는 가용성, 확장성, 지연 시간을 개선하기 위해 일관성을 트레이드오프한다. RDBMS 데이터베이스를 포함한 ACID 데이터베이스는 네트워크 분할이 발생했을 때 쓰기를 수락할 수 없다.

네트워크 분할 중에 쓰기가 발생하면 ACID 일관성을 유지할 수 없기 때문이다. MongoDB, HBase, 레디스는 선형화 가능성을 위해 가용성을 트레이드오프하는 반면, CouchDB, 카산드라, DynamoDB, Hadoop, Riak은 가용성을 위해 선형화 가능성을 트레이드오프한다.

- 전체 메시
- 정족수(Quorum)

단일 위치에 쓰기를 수행하고 이 쓰기를 다른 관련 위치로 전파하는 최종적 일관성 기법
- 이벤트 소싱에서 설명할 트래픽 스파이크를 처리하는 기법
- 조정 서비스
- 분산 캐시

일관성과 정확성을 낮은 비용과 맞바꾸는 최종적 일관성 기법
- 가십 프로토콜
- 무작위 리더 선택

선형화 가능성은 대부분의 노드나 모든 노드가 요청을 처리하기 전 합의해야 하므로 가용성이 낮다. 그리고 더 복잡하며 비용이 많이 든다.

### 3.5.1 전체 메시

전체 메시에서 클러스터의 모든 호스트는 다른 모든 호스트의 주소를 가지고 있으며 모든 호스트에 메시지를 브로드캐스트 한다.

새 호스트가 추가되면 그 주소를 다른 호스트에게 전송하는 방법은 다음과 같다.

- 구성 파일에 주소 목록을 유지한다. 목록이 변경될 때 마다 이 파일을 모든 호스트/노드에게 배포한다.
- 모든 호스트로부터 하트비트를 수신한다. 하트비트를 받는 한 호스트는 계속 등록된 상태로 유지되며 모든 호스트는 이를 통해 전체 주소 목록을 유지한다.

전체 메시는 확장성이 없다. 메시지 수는 호스트 수에 따라 2차적으로 증가한다. 정족수 방식에서 시스템이 데이터 동기화가 이뤄졌다고 불 수 있으려면 과반수의 호스트만 같은 데이터가 있으면 된다. 비트토렌트는 분산 P2P 파일 공유를 위해 전체 메시를 사용하는 프로토콜의 예다.

### 3.5.2 조정 서비스

리더가 있으면 메시지 수가 감소한다. 다른 모든 노드는 리더에게 메시지를 보내고 리더는 필요한 처리를 수행한 후 최종 결과를 다시 보낼 수 있다. 각 노드는 자신의 리더나 리더 집합과 통신하면 되고 각 리더는 일정 수의 노드를 관리한다.

예시 알고리즘으로는 Paxos, Raft, Zab(ZooKeeper Atomic Broadcast)이 있다. 주키퍼는 분산 조정 서비스로써 아래의 기능을 제공한다.
- 접근 제어
- 높은 성능을 위한 메모리 내 데이터 저장
- 주키퍼 앙상블에 호스트를 추가해 수평 확장이 가능한 확장성
- 지정된 시간 범위 내에서 보장된 최종 일관성이나 더 높은 비용으로 강한 일관성 적용. 주키퍼는 일관성을 적용하고 가용성을 트레이드오프하는데 이는 CAP에서 CP 시스템이다.
- 클라이언트가 작성된 순서대로 데이터를 읽을 수 있다.

조정 서비스는 높은 신뢰성을 가져야 하고 오직 하나의 리더만 선출되어야 한다. (두 노드가 모두 자신이 리더라고 믿는 상황을 '스플릿 브레인'이라고 부른다)

### 3.5.3 분산 캐시

레디스나 Memcached같은 분산 캐시를 사용할 수 있다. 서비스의 노드는 새 데이터를 가져올 때 주기적으로 원본에 요청을 보낸 다음 분산 캐시에 요청을 보내 데이터를 업데이트할 수 있다.

### 3.5.4 가십 프로토콜

각 노드는 주기적 또는 무작위 간격으로 다른 노드를 선택한 다음 데이터를 공유한다. 이 방식은 더 낮은 비용과 복잡성을 위해 일관성을 트레이드오프 한다.

카산드라는 분산 데이터 파티션 전체의 일관성을 유지하기 위해 가십 프로토콜을 사용한다. 다이나모DB는 '벡터 시계'라고 불리는 가십 프로토콜을 사용한다.

### 3.5.5 무작위 리더 선택

무작위 리더 선택은 리더를 선출할 때 간단한 알고리즘을 사용하는데, 오직 하나의 리더만을 보장하지 않으므로 여러 리더가 있을 수 있다. 카프카는 내결함성을 제공할 때 무작위 리더 선택과 함께 리더-팔로워 복제 모델을 사용한다.

## 3.6 정확성

최종적으로 일관된 시스템은 가용성, 복잡성, 비용 개선하기 위해 정확성을 트레이드오프한다. 최종적으로 일관된 시스템은 복제본이 쓰기 작업의 영향으로 업데이트될 때 까지 부정확하다.

## 3.7 복잡성과 유지보수성

복잡성을 줄이고 유지보수성을 개선하려면 다음의 공통 서비스를 적극 활용한다.

- 로드 밸런서 서비스
- 속도 제한 방식
- 인증과 인가
- 로깅, 모니터링, 알림
- TLS 종료
- 캐싱
- 데브옵스와 CI/CD

Avro, Thrift, protobuf와 같은 RPC 직렬화 프레임워크는 스키마 파일을 유지해야하는 것을 감수하고 메시지 크기를 줄일 수 있다.

또한 중단이 어떻게 발생할 수 있는지, 다양한 중단이 사용자와 비즈니스에 미치는 영향을 평가하고 중단을 예방/완화하는 방법을 논의해야 한다. 일반적으로 복제, 장애 조치, 런북 작성등이 있다.

### 3.7.1 지속적 배포(CD)

## 3.8 비용

## 3.9 보안

## 3.10 프라이버시

### 3.10.1 외부 서비스 vs 내부 서비스

## 클라우드 네이티브
